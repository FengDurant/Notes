# Notes
进程：正在运行的程序

线程：就是进程中的一个独立控制单元，线程在控制着进程的执行。
      
一个进程至少有一个线程， Java Vm 启动的时候有一个进程java.exe
该进程中至少有一个线程负责Java程序的执行，而且这个线程的代码存在于main方法中，该线程称之为主线程。

扩展：细节说明虚拟机，jvm启动不止一个线程，还有一个垃圾回收机制线程
每次执行结果可能会不同，CPU执行到谁，谁运行
CPU做快速切换，已达到看上去同时运行的效果。形象的吧多线程运行理解为互相抢夺CPU的执行权。

如何在自定义一个线程？？？ Thread
1.继承Thread类      步骤：1. 定义类继承Thread。  2. 复写Thread类中的run方法  目的：将自定义的方法存储在run方法中   3.调用线程中的start方法 （有两个作用启动线程，调用run方法）

为什么使用run方法？？？？   用于存储线程要运行的代码，该存储功能就是run方法， 
线程有独立的一块内存区域。

currentThread():获取当前线程对象
getName():获取线程名称
                          
简单的买票程序：多窗口卖票  卖票代码被多个线程执行
设置static变量，大家共同使用
class Ticket extends Thread
{
	private static int tick = 100;
	public void run()
	{
		while(true)
		{
			if(tick > 0)
			{
			System.out.println(Thread.currentThread().getName() + "sale:" + tick--);
			}
		}
	}
}
public class TickDemo
{
	public static void main(String[] args)
	{
		Ticket t1 = new Ticket();
		Ticket t2 = new Ticket();
		Ticket t3 = new Ticket();
		Ticket t4 = new Ticket();
		
		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}

但也存在弊端

创建线程第二种方式：实现Runable接口

步骤：1. 定义类实现Runable接口 2.覆盖Runable接口中run方法   3.通过Thread类建立线程对象  4.将Runable几口的的子类对象作为实际参数传递给Thread类的构造函数。
      5.调用Thread类的start方法开启线程并调用Runable接口子类的run方法。
      
  实现方式和继承方式有何区别？？？
  实现方式的好处：避免了单继承的方式
  
  继承Thread：线程代码存放在Thread自雷的run方法中
  实现Runnable：线程代码存放在接口的子类的run方法中。
  
  class Ticket implements Runnable
{
	private static int tick = 100;
	public void run()
	{
		while(true)
		{
			if(tick > 0)
			{
			System.out.println(Thread.currentThread().getName() + "sale:" + tick--);
			}
		}
	}
}
public class TickDemo
{
	public static void main(String[] args)
	{
		
		Ticket t = new Ticket();
		
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		
		
		t1.start();
		t2.start();
		t3.start();
		t4.start();		
		
		/*Ticket t1 = new Ticket();
		Ticket t2 = new Ticket();
		Ticket t3 = new Ticket();
		Ticket t4 = new Ticket();
		
		t1.start();
		t2.start();
		t3.start();
		t4.start();*/
	}
}


多线程运行出现安全问题？？    
原因：：： 当多条语句在操作同意线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完

Java队多线程的安全提供了专业的解决方案。  就是同步代码块
     synchronized (对象) {需要被同步的代码}
对象如同锁。持有锁的线程可以再同步中执行。
没有持有锁的线程及时获得cpu的执行权，也进不去，因为没有锁
同步的前提：
1. 必须有两个或两个以上的线程。
2.必须多个线程使用同一个锁。
  必须保证同步中只能有一个线程在运行。

好处：解决多线程的安全问题
弊端：多个线程都需判断锁，较为消耗资源。
  
  如何找问题？？？？？？？？？？？？？？？？？
  1. 明确那些代码是多线程运行代码
  2. 明确共享数据
  3.明确多线程运行代码哪些语句是才做共享数据的。
  
  另一种用同步函数   ：   函数名前加   synchronized
  
  同步函数使用的是哪一个锁？？？？
  函数需要被对象调用，那么函数都有一个所属对象引用 ，就是this
  所以同步函数使用锁是   this  
  
  
  
  
  
  
  
  
  
  
  
  

















