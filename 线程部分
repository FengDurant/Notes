# Notes
进程：正在运行的程序

线程：就是进程中的一个独立控制单元，线程在控制着进程的执行。
      
一个进程至少有一个线程， Java Vm 启动的时候有一个进程java.exe
该进程中至少有一个线程负责Java程序的执行，而且这个线程的代码存在于main方法中，该线程称之为主线程。

扩展：细节说明虚拟机，jvm启动不止一个线程，还有一个垃圾回收机制线程
每次执行结果可能会不同，CPU执行到谁，谁运行
CPU做快速切换，已达到看上去同时运行的效果。形象的吧多线程运行理解为互相抢夺CPU的执行权。

如何在自定义一个线程？？？ Thread
1.继承Thread类      步骤：1. 定义类继承Thread。  2. 复写Thread类中的run方法  目的：将自定义的方法存储在run方法中   3.调用线程中的start方法 （有两个作用启动线程，调用run方法）

为什么使用run方法？？？？   用于存储线程要运行的代码，该存储功能就是run方法， 
线程有独立的一块内存区域。

currentThread():获取当前线程对象
getName():获取线程名称
                          
简单的买票程序：多窗口卖票  卖票代码被多个线程执行
设置static变量，大家共同使用
class Ticket extends Thread
{
	private static int tick = 100;
	public void run()
	{
		while(true)
		{
			if(tick > 0)
			{
			System.out.println(Thread.currentThread().getName() + "sale:" + tick--);
			}
		}
	}
}
public class TickDemo
{
	public static void main(String[] args)
	{
		Ticket t1 = new Ticket();
		Ticket t2 = new Ticket();
		Ticket t3 = new Ticket();
		Ticket t4 = new Ticket();
		
		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}

但也存在弊端

创建线程第二种方式：实现Runable接口

步骤：1. 定义类实现Runable接口 2.覆盖Runable接口中run方法   3.通过Thread类建立线程对象  4.将Runable几口的的子类对象作为实际参数传递给Thread类的构造函数。
      5.调用Thread类的start方法开启线程并调用Runable接口子类的run方法。
      
  实现方式和继承方式有何区别？？？
  实现方式的好处：避免了单继承的方式
  
  继承Thread：线程代码存放在Thread自雷的run方法中
  实现Runnable：线程代码存放在接口的子类的run方法中。
  
  class Ticket implements Runnable
{
	private static int tick = 100;
	public void run()
	{
		while(true)
		{
			if(tick > 0)
			{
			System.out.println(Thread.currentThread().getName() + "sale:" + tick--);
			}
		}
	}
}
public class TickDemo
{
	public static void main(String[] args)
	{
		
		Ticket t = new Ticket();
		
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		
		
		t1.start();
		t2.start();
		t3.start();
		t4.start();		
		
		/*Ticket t1 = new Ticket();
		Ticket t2 = new Ticket();
		Ticket t3 = new Ticket();
		Ticket t4 = new Ticket();
		
		t1.start();
		t2.start();
		t3.start();
		t4.start();*/
	}
}


多线程运行出现安全问题？？    
原因：：： 当多条语句在操作同意线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完

Java队多线程的安全提供了专业的解决方案。  就是同步代码块
     synchronized (对象) {需要被同步的代码}
对象如同锁。持有锁的线程可以再同步中执行。
没有持有锁的线程及时获得cpu的执行权，也进不去，因为没有锁
同步的前提：
1. 必须有两个或两个以上的线程。
2.必须多个线程使用同一个锁。
  必须保证同步中只能有一个线程在运行。

好处：解决多线程的安全问题
弊端：多个线程都需判断锁，较为消耗资源。
  
  如何找问题？？？？？？？？？？？？？？？？？
  1. 明确那些代码是多线程运行代码
  2. 明确共享数据
  3.明确多线程运行代码哪些语句是才做共享数据的。
  
  另一种用同步函数   ：   函数名前加   synchronized
  
  同步函数使用的是哪一个锁？？？？
  函数需要被对象调用，那么函数都有一个所属对象引用 ，就是this
  所以同步函数使用锁是   this  
  
  如果同步函数被静态修饰后，使用的锁是什么？？？？？？
  通过验证，发现不是this。因为静态方法中也不可以定义this
  静态进入内存是，内存中没有本类对象，但是一定有该类对应的字节码文件对象。
  类名.class  该类对象的类型是class
  
  静态的同步方法， 使用的锁是该方法所在字节码文件对象
  
  懒汉式与饿汉时有何不同？？？？？？？？？
  
  //equals 判断内容是否相同
//equalsIgnoreCase 判断内容是否相同，并湖绿大小写
/*
 * 字符转换
 * 3.1 将字符数组转为字符串。
 * 构造函数 String(char[])
 *        String(char[], offset, count);将字符串数组中一部分转为字符串
 *        静态方法： static String copyValueof(char[])
 * 3.2 将字符串转为字符数组。
 * char[] toCharArrary();
 * 3.3 将字节数组转为字符串。
 *     String(Byte[]);
 * 3.4 将字符串转为字节数组。
 *     Byte[] getBytes();
 *     
 *4. 替换 String replace(oldchar, newchar);
 *   如果替换的字符不存在，返回原来的字符串
 *
 *5. 切割 String split(regex)
 *     
 *     
 */
public class Xuetest
{
	public static void methed_split()
	{
		String s = "zhangsan,lisi,wangwu,zhaoliu";
		String[] arr = s.split(",");
		System.out.println(arr[2]);
	}
	
	public static void sop(String str)
	{
		System.out.println(str);
	}
	
	public  static String myTrim(String str)
	{
		int start = 0, end = str.length()-1;
		while(start <= end && str.charAt(start) == ' ')
			start++;
		while (start <= end && str.charAt(end) == ' ')
			end--;
		return str.substring(start, end+1);
	}
	
	public static void main(String args[])
	{
		//methed_split();
		String s = "         123 789jjjj      ";
		sop(myTrim(s));
	}
}


/*
 * StringBuffer是字符串缓冲区，是一个容器
 *       1. 存储
 *         StringBuffer append():将指定数据作为参数添加到该已有数据的结尾处
 *         StringBuffer insert(index, 数据)
 *       2. 删除
 *         Stringbuffer delete(start, end) 包头不包尾
 *         StringBuffer deleteChatAt(index):删除指定位置的字符
 *       3. 获取
 *         char charAt(int index)
 *         int indexof(String str)
 *         int lastindexof)string str)
 *         int length();
 *         String substring(int start, int end)
 * 
 *       4. 修改
 *         StringBuffer replace(start, end, string);
 *         void setCharAt(int index, char ch);
 *         
 *       5. 反转
 *         StringBuffer reverse()
 *         
 *       6. 
 *       
 */
public class StringBufferDemo
{
	public static void main(String args[])
	{
		StringBuffer sb = new StringBuffer("woaini");
//		StringBuffer sb1 = sb.append(34);
//		sb.delete(1, 2);  //
//		sb.delete(0, sb.length()); //清空缓冲区
		
//		sop("sb==sb1"+(sb==sb1));
		sop(sb.toString());

	}
	
	public static void sop(String str)
	{
		System.out.println(str);
	}
}
  
 /*
 * StringBuilder是线程不同步
 * StringBuffer是线程同步
 * 以后开发建议使用Stringbuilder
 */

/*
 * 基本数据类型对象包装类
 * byte    Byte
 * short   Short
 * int     Integer等等
 * 最常见作用
 * 就是用于基本数据类型和字符串类型之间做转换
 * 
 * 基本数据类型转成字符串 ： 接班数据类型+""     ,    toString
 * 字符串转为基本数据类型
 */


  
  
  
  
  
  
  

















