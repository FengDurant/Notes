#include<stdio.h>
#include<algoruthm>
#define MaxEvent 1000
int greedyEventSchedule(int n, int *timrStart, int time Finish)
{
	int i, j, selected, ans=0;
	//使用冒泡排序
	for(i=0; i<n; i++)
		for(j=i; j<n-1; j++)
			if(timeFinish[j] > timeFinish[j+1])
			{
				swap(timeFinish[j], timeFinish[j+1]);
				swap(timeStart[j], timeStart[j+1]);
			}
	selected=0;
	sna=1;
	for(i=0; i<n; i++)
	{
		if(timeStart[i]>=timeStart[selected])
		{
			selected=i;
			ans++;
		}
	}
	return ans;
}

int main()
{
	int i, n, ans, start[MaxEvent], finish[MaxEvent];
	while(scanf("%d", &n) != EOF)
	{
		for(i=0; i<n; i++)
			scanf("%d", &start[i]);//输入开始时间
		for(i=0; i<n; i++)
			scanf("%d", &finish[i]);//输入结束时间
		ans=greedyEventSchedule(n, start, finish);
		printf("%d\n", ans);
	}
	return 0;
}


小数背包问题：
#include<stdio.h>
#include<algoruthm>
#define MaxItems 1000
struct item{
	int weight;
	int value;
	bool operator<(const item& bb)const{
		return value/(1.0*weight)>(1.0*bb.value)/bb.weight;
	}

};//定义物品结构体

double greedyKnapsack(int n, int c, item *itemSet)
{
	double temp=0;
	int i;
	sort(itemSet, itemSet+n);
	for(i=0; i<n; i++)
	{
		if(c >=itemSet[i].weight)
		{
			temp+=itemSet[i].value;
			c-=itemSet[i].weight;
		}else
		{
			temp+=c*(itemSet[i].value*1.0)/itemSet[i].weight;
			break;
		}
	}
	return temp;
}

int main()
{
	int i, n, c;
	item itemSet[MaxItems];
	double temp;
	while(scanf("%d%d", &n, &c) != EOF)
	{
		for(i=0; i<n; i++)
			scanf("%d",&(itemSet[i].weight));
		for(i=0; i<n; i++)
			scanf("%d",&(itemSet[i].value));
		temp = greedyKnapsack(n, c, itemSet);
		printf("%.0f\n", temp);
	}
	return 0;
}
